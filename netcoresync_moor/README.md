# netcoresync_moor

Dart / Flutter Client (opinionated to Moor) for NETCoreSync (a data synchronization library / server component implemented using .NET Core).

## Usage Example

Please check the NETCoreSync's example that uses Flutter [here](https://github.com/aldycool/NETCoreSync/tree/master/Samples/Flutter). The server-side uses .NET Core 5.0 + EntityFramework Core + PostgreSQL, while the client-side uses Flutter + Moor as its offline database. The Flutter project supports all platforms, including Android, iOS, Windows, MacOS, Linux, and Web. Read the documentation on how to deploy the clients. **NOTE: SYNC IS STILL IN WORKS!**

General Guide:
- in `pubspec.yaml`, import `netcoresync_moor` on `dependencies`, and `netcoresync_moor_generator` on `dev_dependencies`, do `flutter pub get`.
- Decorate your Moor's table classes (your classes that extends `Table`, or marked with `@UseRowClass`) with `@NetCoreSyncTable` annotation (read more on its parameters, such as `syncId`, `knowledgeId`, `synced`, and `deleted`).
- If you use `@UseRowClass`, be sure to implement the JSON conversion functions (`toJson()` instance method and `fromJson()` constructor method). If your data classes are generated by Moor (not using `@UseRowClass`), it is expected that they already have these functions, so you don't need to do anything.
- If you use `@UseRowClass`, you must implement an instance method called `toCompanion()` with 1 bool argument called 'nullToAbsent' that returns its Companion version. This is required for the NETCoreSync's `syncWrite()` and `syncReplace()` internal implementations later during updates. This should be implemented exactly like Moor does, by returning an instance of its Companion version, where it is constructed by passing all of your Row Class fields values, and each of those fields values is wrapped with the `Value()` class. Take a look on how Moor implement it for your tables that `extends DataClass` in the generated `*.g.dart` file, especially when handling the `nullToAbsent` argument, where it is expected to use `Value.absent()` for your nullable fields if the `nullToAbsent` parameter is set to `true`.
- On your Moor's Database class (the one with the `@UseMoor` annotation), add the `NetCoreSyncClient` and the `NetCoreSyncClientUser` mixin, for example: `class Database extends _$Database with NetCoreSyncClient, NetCoreSyncClientUser`.
- Inside your `@UseMoor`'s `tables` list, add the `NetCoreSyncKnowledges` class.
- Now perform the source code generation (read the Generate Builds below) like with Moor as usual, the `netcoresync_moor` code will be generated along with Moor's generated code inside the Moor's standard generated file, the `[yourdatabasefile].g.dart`.
- Then, somewhere on your code after your Database class has been instantiated, call the NetCoreSync initialize method like this: `await database.netCoreSyncInitialize();`. This method is already generated for you to execute.
= After that, to start performing CRUDs, you must also call `database.netCoreSyncSetSyncIdInfo()` with parameter of your logged-in user, also you can switch into the one of logged-in user's linked syncIds by calling `database.netCoreSyncSetActiveSyncId()`. Read more on what these does.
- There are differences on doing things. For example, the standard Moor operations like:
  ```sh
  await database.into(someTable).insert(data);
  ```
  Now should be changed like this:
  ```sh
  await database.syncInto(theSyncVersionOfSomeTable).syncInsert(data);
  ```
  NetCoreSync introduces the equivalent counterpart methods like `syncInsert`, `syncReplace`, `syncDelete`, etc., for the standard Moor operations such as `insert`, `replace`, `delete`, etc. Read more on the documentation to find out what the changes are (As per writing, read the `netcoresync_operation_test.dart` on the `test` folder, this test file covers all of the equivalent methods). ~~Also it is required to **wrap any of the equivalent counterpart methods that modifies data (insert, update, delete) inside a Transaction block** as those methods will execute on several tables internally, so atomic operation is needed to ensure the data integrity.~~ (Since the ServerTimeStamp approach, this is not needed anymore)
- TODO: explain on how to do Synchronization
- Restrictions:
  - All restrictions inherited from NetCoreSync
  - In Moor implementation, the primary key column's type must be `String` (usually implemented as Guid). We cannot guarantee its uniqueness if its type is other than `String`.
  - Data classes that uses Moor's @UseRowClass must be mutable (its field values can be changed independently).
  - As per writing (2021-Jul-16), the tests and also the library functions supports `insertReturning` (and its sync equivalent: `syncInsertReturning`), but, neither android, ios, macos or maybe other platforms shipped with the required sqlite version (3.35), so manual installation (or packaging in the output) is necessary to install the sqlite 3.35 or newer. Read more about this issue [here](https://github.com/simolus3/moor/issues/1096).
- Unsupported Moor functions:
  - `batch`: haven't got a clean way on how to work on top of this properly
  - `mode` parameter on `insert` does not support `replace` or `insertOrReplace`, because those modes can actually delete the physical data (which is not supported in our synchronization mechanism, we only do soft-delete).
  - Basically, everything that is not included in the test files.

## Notes

- Generate builds:
  ```sh
  flutter packages pub run build_runner clean
  flutter clean
  flutter pub get
  flutter packages pub run build_runner build --delete-conflicting-outputs
  ```
- Unit tests Code Coverage:
  - ensure the `lcov` application is installed: `brew install lcov` (this installs the `genhtml` application).
  - on the root folder: `flutter test --coverage`, this will create a folder `coverage` with a file `lcov.info` inside.
  - on the root folder: `genhtml -o coverage/genhtml coverage/lcov.info`, this will generate test reports in html files, the starting html index file is in `coverage/genhtml/index.html`.
  - NOTE: by default, the `coverage` folder is git-ignored.

## Dev Notes

- Make effort later to reduce the generated code, remove stuffs that is not necessary.
- Update 210707: After seeing latest efforts in testing the concepts, it seems that at this point which is only half the battle (doing getters and setters with `reflectable` on Moor's custom row classes), not to mention the rest of the way (making Moor's "queryables" to work with reflection, etc), most likely the pristine approach of NETCoreSync's "database-agnostic" will be dropped in favor of "Moor-opinionated", because if we keep moving forward, there will be a LOT of work when we try to subclassing the `SyncEngine` in Dart / Flutter environment (due to the lack of Reflection in Flutter). I feel that everybody is leaning towards "code-generation" approaches to overcome the lack of reflection support in Flutter. So the next move now, is to design a "builder" that works on top of the Moor's generated file, to make it very easy to work with Flutter-based NETCoreSync.
- SyncConfiguration does not support assemblies, and by default uses DatabaseTimeStamp strategy, so any non-related functions will be ommited. Also don't be opiniated to Moor, at the very least we only need what are the extended property names are (lastUpdated, deleted, databaseInstanceId) of every Type processed.
- Combination of synchronizationId + databaseInstanceId make up a unique User with its one device, so if he have two devices, he should have a single synchronizationId with two different databaseInstanceId.
- The HookPreInsertOrUpdateDatabaseTimeStamp + HookPreDeleteDatabaseTimeStamp is modifying the extended properties (lastUpdated, deleted, databaseInstanceId) for you, don't do it yourself
- On clients (not on server database where it should keep track all users data) the synchronizationId should not be persisted to Knowledge table because it is assumed the the client's database will only have one user data (TO BE INVESTIGATED, BECAUSE WE WILL NEED TO SUPPORT IMPORTING OTHER USER DATA LATER). UPDATE: I think now we have to change all approaches to be like Server-To-Server if we want our users to import and modify each other's data, still in thinking cap...
- Should rename HookPreInsertOrUpdateDatabaseTimeStamp => HookPreInsertOrUpdate 
- DART IN FLUTTER DOESN'T HAVE REFLECTION, read more below! Dart should be able to get/set value to an object based on string name
- OK - Dart should be able to pass by ref (modify the passed object properties) and have the modification on the next codes.
- Flutter doesn't support dart:mirrors (NO REFLECTION SUPPORT), and I know there's a package called `reflectable.dart`, but still.. read the next point.
- Avoid using too many package dependencies, in my experience, the more you use external dependencies, the higher the risk of something breaks in the future
- We may have to continue without reflection, just use interfaces (and more work on the implementation to assign `lastUpdated`, etc.)
- Also I'd like to stay with the current server-side .NET Core with no changes (if possible)
