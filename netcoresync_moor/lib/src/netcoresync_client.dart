import 'package:meta/meta.dart';
import 'package:moor/moor.dart';
import 'netcoresync_exceptions.dart';
import 'netcoresync_engine.dart';
import 'netcoresync_classes.dart';
import 'data_access.dart';
import 'client_select.dart';
import 'client_insert.dart';
import 'client_update.dart';
import 'client_delete.dart';
import 'sync_session.dart';

/// The main mixin class that provides the synchronization method and
/// replacement methods for the standard Moor's method calls that is compatible
/// with synchronization.
///
/// This class should be mixed with the main Moor database class (the class
/// that is annotated with `@UseMoor`). There's also a mixin class called
/// `NetCoreSyncClientUser` (which created during code generation) that also
/// should be mixed with the database class. For example:
/// ```dart
/// @UseMoor(
///   tables: [
///     // ...some table classes here...
///     NetCoreSyncKnowledges,
///   ],
/// )
/// class Database extends _$Database
///     with NetCoreSyncClient, NetCoreSyncClientUser {
/// // ... class code here ...
/// }
/// ```
/// Later after the database class has been instantiated in code, it should call
/// the framework initialization method called `netCoreSyncInitialize()`. Read
/// the [Client Side Initialization](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-initialization)
/// in the `netcoresync_moor` documentation for more details.
///
/// _NOTE: The `netCoreSyncInitialize()` method is created during code
/// generation, which in turns calls the [netCoreSyncInitializeClient()], and
/// the `netCoreSyncInitializeUser()` method that is generated inside the
/// `NetCoreSyncClientUser` class._
mixin NetCoreSyncClient on GeneratedDatabase {
  DataAccess? _dataAccess;

  /// Indicates whether the framework has been initialized (by calling
  /// `netCoreSyncInitialize()`) or not.
  bool get netCoreSyncInitialized => _dataAccess != null;

  /// *(This property is used internally, no need to use it directly)*
  @internal
  DataAccess get dataAccess {
    if (!netCoreSyncInitialized) throw NetCoreSyncNotInitializedException();
    return _dataAccess!;
  }

  /// One of the initialization methods that is invoked by the
  /// `netCoreSyncInitialize()` call.
  ///
  /// *(This method is used internally, no need to use it directly)*
  Future<void> netCoreSyncInitializeClient(
    NetCoreSyncEngine engine,
  ) async {
    _dataAccess = DataAccess(
      this,
      engine,
    );
  }

  /// *(This property is used internally, no need to use it directly)*
  dynamic get netCoreSyncResolvedEngine => dataAccess.databaseResolvedEngine;

  /// Assign a function handler which receives the `object` parameter, where
  /// `object` is a log data generated by the framework. This can be used to
  /// setup a custom logger in the project.
  void netCoreSyncSetLogger(void Function(Object? object) logger) {
    dataAccess.logger = logger;
  }

  /// Get the currently assigned [SyncIdInfo] in the framework. This will return
  /// `null` if the [netCoreSyncSetSyncIdInfo()] method hasn't been called.
  ///
  /// Read more about this method in [Client Side Initialization](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-initialization)
  /// in the `netcoresync_moor` documentation for more details.
  SyncIdInfo? netCoreSyncGetSyncIdInfo() => dataAccess.syncIdInfo;

  /// Set the currently active [SyncIdInfo].
  ///
  /// Read more about this method in [Client Side Initialization](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-initialization)
  /// in the `netcoresync_moor` documentation for more details.
  void netCoreSyncSetSyncIdInfo(SyncIdInfo value) {
    if (!netCoreSyncInitialized) throw NetCoreSyncNotInitializedException();
    if (value.syncId.isEmpty) {
      throw NetCoreSyncException("SyncIdInfo.syncId cannot be empty");
    }
    if (value.linkedSyncIds.isNotEmpty && value.linkedSyncIds.contains("")) {
      throw NetCoreSyncException(
          "SyncIdInfo.linkedSyncIds should not contain empty string");
    }
    if (value.linkedSyncIds.isNotEmpty &&
        value.linkedSyncIds.contains(value.syncId)) {
      throw NetCoreSyncException(
          "SyncIdInfo.linkedSyncIds cannot contain the syncId itself");
    }
    dataAccess.syncIdInfo = value;
    dataAccess.activeSyncId = dataAccess.syncIdInfo!.syncId;
  }

  /// Get the active `syncId` from the assigned [SyncIdInfo].
  ///
  /// Read more about this method in [Client Side Initialization](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-initialization)
  /// in the `netcoresync_moor` documentation for more details.
  String? netCoreSyncGetActiveSyncId() => dataAccess.activeSyncId;

  /// Set the active `syncId` from the assigned [SyncIdInfo].
  ///
  /// The `value` must be equal to the assigned [SyncIdInfo.syncId], or one of
  /// the `syncId` listed in the [SyncIdInfo.linkedSyncIds] (if any).
  /// Read more about this method in [Client Side Initialization](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-initialization)
  /// in the `netcoresync_moor` documentation for more details.
  void netCoreSyncSetActiveSyncId(String value) {
    if (!netCoreSyncInitialized) throw NetCoreSyncNotInitializedException();
    if (dataAccess.syncIdInfo == null) {
      throw NetCoreSyncSyncIdInfoNotSetException();
    }
    if (value.isEmpty) {
      throw NetCoreSyncException("The active syncId cannot be empty");
    }
    if (dataAccess.syncIdInfo!.syncId != value &&
        !dataAccess.syncIdInfo!.linkedSyncIds.contains(value)) {
      throw NetCoreSyncException(
          "The active syncId is different than the SyncIdInfo.syncId and also "
          "cannot be found in the SyncIdInfo.linkedSyncIds");
    }
    dataAccess.activeSyncId = value;
  }

  /// *(This method is used internally, no need to use it directly)*
  String netCoreSyncAllSyncIds() {
    if (dataAccess.syncIdInfo == null) {
      return "";
    }
    List<String> allSyncIds = dataAccess.syncIdInfo!.getAllSyncIds();
    return allSyncIds.join(", ");
  }

  /// Starts the synchronization process.
  ///
  /// The `url` is the `NETCoreSyncServer` websocket url that is already setup
  /// to receive synchronization requests. The `syncEvent` is an instance of
  /// [SyncEvent] to monitor the synchronization progress. The
  /// `syncResultLogLevel` is a [SyncResultLogLevel] `enum` to determine the
  /// verbosity of the log results in the returned [SyncResult]. The
  /// `customInfo` is a custom information that can be passed on to the
  /// server-side for information that is not covered by this framework. The
  /// returned [SyncResult] carries errors information (if any) and detailed
  /// log results.
  ///
  /// Please read the [Client Side Synchronization](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-synchronization)
  /// in the `netcoresync_moor` documentation for more details.
  Future<SyncResult> netCoreSyncSynchronize({
    required String url,
    SyncEvent? syncEvent,
    SyncResultLogLevel syncResultLogLevel = SyncResultLogLevel.fullData,
    Map<String, dynamic> customInfo = const {},
  }) async {
    if (!netCoreSyncInitialized) throw NetCoreSyncNotInitializedException();
    if (dataAccess.syncIdInfo == null) {
      throw NetCoreSyncSyncIdInfoNotSetException();
    }
    if (dataAccess.inTransaction()) {
      throw NetCoreSyncMustNotInsideTransactionException();
    }

    SyncSession syncSession = SyncSession(
      dataAccess: dataAccess,
      url: url,
      syncEvent: syncEvent,
      syncResultLogLevel: syncResultLogLevel,
      customInfo: customInfo,
    );

    return syncSession.synchronize();
  }

  /// The replacement method for Moor's [select()]. Use this method to ensure
  /// compatibility with the synchronization process.
  ///
  /// Please read the [Client Side Moor Code Adaptation](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-moor-code-adaptation)
  /// in the `netcoresync_moor` documentation for more details.
  SyncSimpleSelectStatement<T, R> syncSelect<T extends HasResultSet, R>(
    SyncBaseTable<T, R> table, {
    bool distinct = false,
  }) {
    if (!netCoreSyncInitialized) throw NetCoreSyncNotInitializedException();
    return SyncSimpleSelectStatement(
      dataAccess,
      table as ResultSetImplementation<T, R>,
      distinct: distinct,
    );
  }

  /// The replacement method for Moor's [selectOnly()]. Use this method to ensure
  /// compatibility with the synchronization process.
  ///
  /// Please read the [Client Side Moor Code Adaptation](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-moor-code-adaptation)
  /// in the `netcoresync_moor` documentation for more details.
  SyncJoinedSelectStatement<T, R> syncSelectOnly<T extends HasResultSet, R>(
    SyncBaseTable<T, R> table, {
    bool distinct = false,
  }) {
    if (!netCoreSyncInitialized) throw NetCoreSyncNotInitializedException();
    return SyncJoinedSelectStatement<T, R>(
      dataAccess,
      table as ResultSetImplementation<T, R>,
      [],
      distinct,
      false,
    );
  }

  /// The replacement method for Moor's [into()]. Use this method to ensure
  /// compatibility with the synchronization process.
  ///
  /// Please read the [Client Side Moor Code Adaptation](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-moor-code-adaptation)
  /// in the `netcoresync_moor` documentation for more details.
  SyncInsertStatement<T, D> syncInto<T extends Table, D>(
    TableInfo<T, D> table,
  ) {
    if (!netCoreSyncInitialized) throw NetCoreSyncNotInitializedException();
    TableInfo<T, D> normalizedTable = table;
    if (table is SyncBaseTable<T, D>) {
      normalizedTable =
          dataAccess.engine.tables[D]!.tableInfo as TableInfo<T, D>;
    }
    return SyncInsertStatement<T, D>(
      dataAccess,
      normalizedTable,
    );
  }

  /// The replacement method for Moor's [update()]. Use this method to ensure
  /// compatibility with the synchronization process.
  ///
  /// Please read the [Client Side Moor Code Adaptation](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-moor-code-adaptation)
  /// in the `netcoresync_moor` documentation for more details.
  SyncUpdateStatement<T, D> syncUpdate<T extends Table, D>(
    TableInfo<T, D> table,
  ) {
    if (!netCoreSyncInitialized) throw NetCoreSyncNotInitializedException();
    TableInfo<T, D> normalizedTable = table;
    if (table is SyncBaseTable<T, D>) {
      normalizedTable =
          dataAccess.engine.tables[D]!.tableInfo as TableInfo<T, D>;
    }
    return SyncUpdateStatement<T, D>(
      dataAccess,
      normalizedTable,
    );
  }

  /// The replacement method for Moor's [delete()]. Use this method to ensure
  /// compatibility with the synchronization process.
  ///
  /// Please read the [Client Side Moor Code Adaptation](https://github.com/aldycool/NETCoreSync/tree/master/netcoresync_moor#client-side-moor-code-adaptation)
  /// in the `netcoresync_moor` documentation for more details.
  SyncDeleteStatement<T, D> syncDelete<T extends Table, D>(
    TableInfo<T, D> table,
  ) {
    if (!netCoreSyncInitialized) throw NetCoreSyncNotInitializedException();
    TableInfo<T, D> normalizedTable = table;
    if (table is SyncBaseTable<T, D>) {
      normalizedTable =
          dataAccess.engine.tables[D]!.tableInfo as TableInfo<T, D>;
    }
    return SyncDeleteStatement<T, D>(
      dataAccess,
      normalizedTable,
    );
  }
}
